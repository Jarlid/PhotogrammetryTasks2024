# Перечислите идеи и коротко обозначьте мысли которые у вас возникали по мере выполнения задания, в частности попробуйте ответить на вопросы:

### 1) Почему SIFT менее точно угадывает средний угол отклонения? изменяется ли ситуация если выкрутить параметр ORIENTATION_VOTES_PEAK_RATIO=0.999? почему?

I, honestly, have no idea. Brain empty, no thoughts.

При выставлении ```ORIENTATION_VOTES_PEAK_RATIO = 0.999``` угол отклонения вычисляется куда более точно.
Предполагаю, что это связано с тем, что в этом варианте направление-победитель ровно одно почти во всех случаях.

### 2) Как надежно замерить во сколько раз распараллеливание через OpenMP ускоряет ваш вариант SIFT? Попробуйте сделать это на вашем компьютере, какое ускорение относительно однопоточной версии оказалось? Сколько у вашего процессора ядер и сколько потоков?

Вообще, правильно запускать эксперимент много раз, и брать всякие величины из получившейся выборки,
а также самому следить, в каких местах вызывается таймер, but I'm too lazy to do this. ¯ \ _ (ツ) _ / ¯

Так что я просто воткнул строчку ```omp_set_num_threads(1)```, и представляю таблицу результатов:

<details><summary>Замеры времени в секундах.</summary>

| Тест                         | 1 поток | Все потоки |
|------------------------------|---------|------------|
| SIFT.MovedTheSameImage       | 6.99591 | 1.76749    |
| SIFT.MovedImageRight         | 7.20633 | 1.69296    |
| SIFT.MovedImageLeft          | 6.96409 | 1.7871     |
| SIFT.MovedImageUpHalfPixel   | 6.91545 | 1.83868    |
| SIFT.MovedImageDownHalfPixel | 6.58415 | 1.75543    |
| SIFT.Rotate10                | 7.0774  | 2.12499    |
| SIFT.Rotate20                | 6.63232 | 1.90577    |
| SIFT.Rotate30                | 6.62184 | 2.00884    |
| SIFT.Rotate40                | 6.55931 | 1.85627    |
| SIFT.Rotate45                | 6.45541 | 1.80236    |
| SIFT.Rotate90                | 6.41003 | 1.88853    |
| SIFT.Scale50                 | 5.24869 | 1.65587    |
| SIFT.Scale70                 | 5.70112 | 1.63373    |
| SIFT.Scale90                 | 7.3952  | 1.80844    |
| SIFT.Scale110                | 6.80184 | 1.95709    |
| SIFT.Scale130                | 6.98738 | 2.06438    |
| SIFT.Scale150                | 7.71654 | 2.09131    |
| SIFT.Scale175                | 8.25072 | 2.28275    |
| SIFT.Scale200                | 8.72403 | 2.20361    |
| SIFT.Rotate10Scale90         | 6.4463  | 1.76884    |
| SIFT.Rotate30Scale75         | 6.01373 | 1.82799    |
| SIFT.HerzJesu19RotateM40     | 260.419 | 52.6173    |

Я чуть ли не помер, пока заполнял эту таблицу.

</details>

Кажется, что ускорение в 3-6 раз -- вполне адекватно для 6-ядерного процессора.

### 3) Правда ли можно строить каждый слой в Gaussian пирамиде из самого первого слоя этой октавы? Или нужно обязательно делать так как предложено в статье - дополняя размытие предыдущего слоя этой октавы? Совпадают ли пирамиды визуально?

Вроде бы правда. По крайней мере, на мой взгляд итоговые картинки не отличаются.
Вероятно, конечно, что несколько пикселей могут немного отличаться в тоне из-за погрешности хранения вещественных чисел,
но кажется, что это не критично.

### 4) Какие ожидания от картинок в Gaussian пирамиде можно придумать? Как проверить что работает корректно? С какой другой картинкой предыдущей октавы должна визуально совпадать конкретная картинка конкретной октавы? Как их визуально сравнить, ведь они разного размера?

Картинки между октавами становятся меньше, а картинки в одной октаве -- более и более размытыми.))0)

Заметим, что формула для сигмы текущего слоя выглядит так: ```INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(k, layer)```.
И если мы сравниваем картинку с картинкой предыдущей октавы,
то ```Δpow(k, layer)``` должна равняться ```1 / Δpow(2.0, octave)```, что равно 1 / 2 в нашем случае.
И с учётом, что при наших данных ```k = 2 ^ (1 / 3)```, то ```layer``` должен быть равен ```-3```,
т.е. нулевому слою октавы соответствует третий слой предыдущей октавы.

...и-и-и вся эта логика может пойти в мусорку, потому что изображения явно размыты неодинаково. Идеи закончились.

### 5) Почему в октаве Gaussian пирамиды s+3 картинки а не s+2 например?

Если мы хотим получить S экстремумов, то нам нужно S+2 DoG слоёв, чтобы эти экстремумы найти
(по +1 для каждой границы), а чтобы получить S+2 DoG слоёв, нам нужно S+2+1 = S+3 Gaussian-слоёв.

### 6) Какие ожидания от картинок в DoG пирамиде можно придумать?

Кажется, что картинки в DoG должны быть в основном чёрными, а осветления, соответствующие деталям,
должны по "размеру" (толщине полос, например) быть близки к соответствующей сигме.

### 7) Почему порог контрастности должен уменьшаться при увеличении числа слоев в октаве?

Слой в DoG -- элементы какой-то частоты, которые попали в разность Gaussian-слоёв. Чем больше слоёв в DoG-пироге,
тем меньше элементов попадает в каждый слой, а следовательно, уменьшается средняя контрастность.
Так что порог контрастности для малого количества слоёв может спокойно замести абсолютно всё при большом количестве.

### 8) Какая строка ответственна за определение сигмы (или что почти то же самое - радиуса) которая задает окрестность по которой определяется ориентация ключевой точки?

Предположу, что ```247: double sigmaCur = INITIAL_IMG_SIGMA * pow(2.0, octave) * pow(k, layer);```

### 9) За какой строки вашего кода дескриптор инвариантен к повороту картинки?

Предположу, что ```361: cv::transform(shiftInVector, shiftInVector, relativeShiftRotation);```